======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Hanxiao Wang

Processing all weeks found in repository

Your current Git repo size is about 147.79 KiB on disk

Found directories: .git, week1, week4, week2, Feedback
Found files: .gitignore, README.md

Processing all weeks: week1, week4, week2

Found 35 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: lc2.py

Contents:

**********
#!/usr/bin/env python3
"""
lc2.py — Slightly trickier list/dict/set comprehensions.
"""
from typing import Dict, Iterable, List, Tuple

def word_lengths(words: Iterable[str]) -> Dict[str, int]:
    return {w: len(w) for w in words}

def vowels_only(s: str) -> List[str]:
    return [ch for ch in s if ch.lower() in "aeiou"]

def cartesian_comp(a: Iterable[int], b: Iterable[int]) -> List[Tuple[int,int]]:
    return [(x,y) for x in a for y in b]

def invert_dict(d: Dict[str, int]) -> Dict[int, List[str]]:
    # value-> list of keys
    inv: Dict[int, List[str]] = {}
    for k, v in d.items():
        inv.setdefault(v, []).append(k)
    return inv

if __name__ == "__main__":
    words = ["eco","evo","bio","python",""]
    print("[lc2] word_lengths:", word_lengths(words))
    print("[lc2] vowels_only('MulQuaBio'):", vowels_only("MulQuaBio"))
    print("[lc2] cartesian_comp([1,2],[10,20]):", cartesian_comp([1,2],[10,20]))
    print("[lc2] invert_dict({'a':1,'b':2,'c':1}):", invert_dict({"a":1,"b":2,"c":1}))

**********

Output (first 500 chars):

**********
[lc2] word_lengths: {'eco': 3, 'evo': 3, 'bio': 3, 'python': 6, '': 0}
[lc2] vowels_only('MulQuaBio'): ['u', 'u', 'a', 'i', 'o']
[lc2] cartesian_comp([1,2],[10,20]): [(1, 10), (1, 20), (2, 10), (2, 20)]
[lc2] invert_dict({'a':1,'b':2,'c':1}): {1: ['a', 'c'], 2: ['b']}

**********
No errors.
======================================================================
Script: Vectorize2.py

Contents:

**********
#!/usr/bin/env python3
"""
Vectorize2.py — compare loop vs NumPy vectorization on L2 norm (sum of squares).
Prints per-N function timings with a stable, greppable format.
"""
import time, math
import numpy as np

def l2_loop(a: np.ndarray) -> float:
    s = 0.0
    for i in range(len(a)):
        s += a[i] * a[i]
    return math.sqrt(s)

def l2_vect(a: np.ndarray) -> float:
    return float(np.linalg.norm(a))

def bench_once(fn, *args, repeats=5):
    tmin = math.inf
    for _ in range(repeats):
        t0 = time.perf_counter()
        _ = fn(*args)
        t = (time.perf_counter() - t0) * 1000.0
        if t < tmin: tmin = t
    return tmin

def main():
    rng = np.random.default_rng(123)
    sizes = [10**k for k in range(1, 7)]
    for N in sizes:
        a = rng.random(N, dtype=np.float64)
        t_loop = bench_once(l2_loop, a)
        t_vect = bench_once(l2_vect, a)
        print(f"TIMING Vectorize2 loop N={N} ms={t_loop:.4f}")
        print(f"TIMING Vectorize2 vect N={N} ms={t_vect:.4f}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
TIMING Vectorize2 loop N=10 ms=0.0013
TIMING Vectorize2 vect N=10 ms=0.0012
TIMING Vectorize2 loop N=100 ms=0.0111
TIMING Vectorize2 vect N=100 ms=0.0010
TIMING Vectorize2 loop N=1000 ms=0.1117
TIMING Vectorize2 vect N=1000 ms=0.0014
TIMING Vectorize2 loop N=10000 ms=1.1609
TIMING Vectorize2 vect N=10000 ms=0.0055
TIMING Vectorize2 loop N=100000 ms=11.7326
TIMING Vectorize2 vect N=100000 ms=0.0494
TIMING Vectorize2 loop N=1000000 ms=126.0593
TIMING Vectorize2 vect N=1000000 ms=0.4268

**********
No errors.
======================================================================
Script: Vectorize1.py

Contents:

**********
#!/usr/bin/env python3
"""
Vectorize1.py — compare loop vs NumPy vectorization on elementwise product & sum.
Prints per-N function timings with a stable, greppable format.
"""
import time, math
import numpy as np

def product_loop(a: np.ndarray, b: np.ndarray) -> float:
    s = 0.0
    for i in range(len(a)):
        s += a[i] * b[i]
    return s

def product_vect(a: np.ndarray, b: np.ndarray) -> float:
    return float((a * b).sum())

def bench_once(fn, *args, repeats=5):
    tmin = math.inf
    for _ in range(repeats):
        t0 = time.perf_counter()
        _ = fn(*args)
        t = (time.perf_counter() - t0) * 1000.0  # ms
        if t < tmin: tmin = t
    return tmin

def main():
    rng = np.random.default_rng(42)
    sizes = [10**k for k in range(1, 7)]  # 10..1,000,000
    for N in sizes:
        a = rng.random(N, dtype=np.float64)
        b = rng.random(N, dtype=np.float64)
        t_loop = bench_once(product_loop, a, b)
        t_vect = bench_once(product_vect, a, b)
        print(f"TIMING Vectorize1 loop N={N} ms={t_loop:.4f}")
        print(f"TIMING Vectorize1 vect N={N} ms={t_vect:.4f}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
TIMING Vectorize1 loop N=10 ms=0.0013
TIMING Vectorize1 vect N=10 ms=0.0011
TIMING Vectorize1 loop N=100 ms=0.0122
TIMING Vectorize1 vect N=100 ms=0.0011
TIMING Vectorize1 loop N=1000 ms=0.1194
TIMING Vectorize1 vect N=1000 ms=0.0013
TIMING Vectorize1 loop N=10000 ms=1.2201
TIMING Vectorize1 vect N=10000 ms=0.0053
TIMING Vectorize1 loop N=100000 ms=12.4210
TIMING Vectorize1 vect N=100000 ms=0.0621
TIMING Vectorize1 loop N=1000000 ms=125.4371
TIMING Vectorize1 vect N=1000000 ms=1.8277

**********
No errors.
======================================================================
Script: dictionary.py

Contents:

**********
#!/usr/bin/env python3
"""
dictionary.py — Common dictionary patterns.
"""
from typing import Dict, Iterable, List, Tuple
from collections import defaultdict

def count_tokens(tokens: Iterable[str]) -> Dict[str, int]:
    cnt: Dict[str, int] = defaultdict(int)
    for t in tokens:
        cnt[t] += 1
    return dict(cnt)

def list_of_tuples_to_dict(pairs: Iterable[Tuple[str, int]]) -> Dict[str, int]:
    return {k: v for k, v in pairs}

def dict_to_sorted_items(d: Dict[str,int]) -> List[Tuple[str,int]]:
    return sorted(d.items(), key=lambda kv: (kv[1], kv[0]))

def merge_sum(d1: Dict[str,int], d2: Dict[str,int]) -> Dict[str,int]:
    out = dict(d1)
    for k, v in d2.items():
        out[k] = out.get(k, 0) + v
    return out

if __name__ == "__main__":
    toks = ["a","b","a","c","b","a"]
    print("[dict] count_tokens:", count_tokens(toks))
    pairs = [("x",2),("y",1)]
    print("[dict] list_of_tuples_to_dict:", list_of_tuples_to_dict(pairs))
    print("[dict] dict_to_sorted_items:", dict_to_sorted_items({"x":2,"y":1,"z":1}))
    print("[dict] merge_sum:", merge_sum({"a":1,"b":2},{"b":5,"c":3}))

**********

Output (first 500 chars):

**********
[dict] count_tokens: {'a': 3, 'b': 2, 'c': 1}
[dict] list_of_tuples_to_dict: {'x': 2, 'y': 1}
[dict] dict_to_sorted_items: [('y', 1), ('z', 1), ('x', 2)]
[dict] merge_sum: {'a': 1, 'b': 7, 'c': 3}

**********
No errors.
======================================================================
Script: compare_vectorization.sh

Contents:

**********
#!/usr/bin/env bash
# Compare R vs Python timings for equivalent vectorized/loop functions.
set -euo pipefail
HERE="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

PY="${PYTHON:-python}"
RSCRIPT="${RSCRIPT:-Rscript}"

P_VEC1="${HERE}/Vectorize1.py"
P_VEC2="${HERE}/Vectorize2.py"
R_VEC1="${HERE}/Vectorize1.R"
R_VEC2="${HERE}/Vectorize2.R"

echo "== Running Python Vectorize1/2 =="
$PY "$P_VEC1" | tee /tmp/py_vec1.out
$PY "$P_VEC2" | tee /tmp/py_vec2.out

echo
echo "== Running R Vectorize1/2 =="
$RSCRIPT "$R_VEC1" | tee /tmp/r_vec1.out
$RSCRIPT "$R_VEC2" | tee /tmp/r_vec2.out

echo
echo "== Summary (function-level timings, ms) =="
printf "%-20s %-10s %-12s %-12s\n" "Case" "N" "Python" "R"
join_lines () {
  awk -v tag="$1" '
    $1=="TIMING" && $2==tag { 
      # TIMING Vectorize1 loop N=1000 ms=0.1234
      for(i=1;i<=NF;i++){ if($i ~ /^N=/){n=substr($i,3)} if($i ~ /^ms=/){ms=substr($i,4)} }
      print n, ms
    }' "$2" | sort -n
}

for kind in "Vectorize1" "Vectorize2"; do
  for mode in "loop" "vect"; do
    echo
    echo "-- ${kind} ${mode} --"
    py_file="/tmp/$( [ "$kind" = "Vectorize1" ] && echo py_vec1.out || echo py_vec2.out )"
    r_file="/tmp/$( [ "$kind" = "Vectorize1" ] && echo r_vec1.out || echo r_vec2.out )"
    paste <(join_lines "$kind" "$py_file" | awk '{print $1" "$2}') \
          <(join_lines "$kind" "$r_file" | awk '{print $1" "$2}') \
      | awk -v k="$kind" -v m="$mode" '
        { printf "%-20s %-10s %-12s %-12s\n", k" "m, $1, $2, $4 }'
  done
done

**********

Output (first 500 chars):

**********
== Running Python Vectorize1/2 ==

**********
Errors:
**********
compare_vectorization.sh: line 15: python: command not found

**********
======================================================================
Script: cfexercises1.py

Contents:

**********
#!/usr/bin/env python3
"""
cfexercises1.py — Control-flow exercises rewritten as a reusable module.

Run directly to see demo evaluations; import to reuse functions elsewhere.
"""
__author__ = "Your Name <you@example.com>"
__version__ = "0.1.0"

from typing import List

def foo_1(x: float = 4.0) -> float:
    """Square root (example control-flow kept trivial)."""
    return x ** 0.5

def foo_2(x: float, y: float):
    """Return the larger of two numbers."""
    return x if x > y else y

def foo_3(x: float, y: float, z: float) -> List[float]:
    """Return [x,y,z] sorted ascending (no .sort used to mirror notes)."""
    if x > y: x, y = y, x
    if x > z: x, z = z, x
    if y > z: y, z = z, y
    return [x, y, z]

def foo_4(n: int) -> int:
    """Factorial via for-loop; handles 0! = 1."""
    if n < 0:
        raise ValueError("n must be >= 0")
    out = 1
    for i in range(1, n+1):
        out *= i
    return out

def foo_5(n: int) -> int:
    """Factorial via recursion; handles 0! = 1."""
    if n < 0:
        raise ValueError("n must be >= 0")
    if n in (0, 1):
        return 1
    return n * foo_5(n-1)

def foo_6(n: int) -> int:
    """Factorial via while-loop; handles 0! = 1."""
    if n < 0:
        raise ValueError("n must be >= 0")
    out = 1
    while n >= 1:
        out *= n
        n -= 1
    return out

def _demo():
    print("foo_1(9)   ->", foo_1(9))
    print("foo_2(7,3) ->", foo_2(7,3))
    print("foo_3(9,1,5) ->", foo_3(9,1,5))
    print("foo_4(5)   ->", foo_4(5))
    print("foo_5(10)  ->", foo_5(10))  # 文档示例中的测试方式
    print("foo_6(6)   ->", foo_6(6))

if __name__ == "__main__":
    _demo()

**********

Output (first 500 chars):

**********
foo_1(9)   -> 3.0
foo_2(7,3) -> 7
foo_3(9,1,5) -> [1, 5, 9]
foo_4(5)   -> 120
foo_5(10)  -> 3628800
foo_6(6)   -> 720

**********
No errors.
======================================================================
Script: LVspeedtest.py

Contents:

**********
#!/usr/bin/env python3
"""
run_LV.py — Run & profile LV1.py (CT), LV2.py (CT+K), LV3.py (DT+K), LV4.py (DT+K+noise).
Print wall-clock timings and cProfile summaries (top tail).
"""
import subprocess, sys, time
from pathlib import Path

HERE = Path(__file__).resolve().parent
PY = sys.executable

LV1 = HERE / "LV1.py"
LV2 = HERE / "LV2.py"
LV3 = HERE / "LV3.py"
LV4 = HERE / "LV4.py"

COMMON_CT = ["--r","1.0","--a","0.5","--z","0.3","--e","0.75","--tmax","80","--dt","0.005","--R0","10","--C0","5"]
LV2_ONLY   = ["--K","50"]
COMMON_DT = ["--r","1.0","--a","0.5","--z","0.3","--e","0.75","--tmax","80","--R0","10","--C0","5","--K","50"]
LV4_ONLY  = ["--sigma","0.05","--seed","1"]

def run_timed(cmd):
    t0 = time.perf_counter()
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    dt = time.perf_counter() - t0
    return p.returncode, dt, p.stdout.strip(), p.stderr.strip()

def profile_script(script, args):
    cmd = [PY, "-m", "cProfile", "-s", "tottime", str(script), *args]
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return p.returncode, p.stdout.strip(), p.stderr.strip()

def section(title): print("\n" + title + "\n" + "="*len(title))

def do_one(name, script, args):
    rc, secs, out, err = run_timed([PY, str(script), *args])
    print(f"[{name}] rc={rc}, time={secs:.3f}s")
    if out: print(f"[{name}] stdout:", out)
    if err: print(f"[{name}] stderr:", err)
    prc, prof, perr = profile_script(script, args)
    tail = "\n".join(prof.splitlines()[-15:])
    print(f"[{name} profile]\n{tail}")
    if perr: print(f"[{name} profile stderr]\n{perr}")

def main():
    for f in (LV1,LV2,LV3,LV4):
        if not f.exists():
            print(f"WARNING: {f.name} not found — skipping its tests.")

    section("Wall-clock timing & profile")
    if LV1.exists(): do_one("LV1", LV1, COMMON_CT)
    if LV2.exists(): do_one("LV2", LV2, [*COMMON_CT, *LV2_ONLY])
    if LV3.exists(): do_one("LV3", LV3, COMMON_DT)
    if LV4.exists(): do_one("LV4", LV4, [*COMMON_DT, *LV4_ONLY])

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********

Wall-clock timing & profile
===========================
[LV1] rc=0, time=0.535s
[LV1] stdout: [OK] Saved: LV_model_timeseries.pdf, LV_model_phaseplane.pdf -> /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results
[LV1 profile]
        1    0.000    0.000    0.000    0.000 exceptions.py:74(VisibleDeprecationWarning)
        1    0.000    0.000    0.000    0.000 patches.py:3507(CurveFilledB)
        1    0.000    0.000    0.000    0.000 subproces
**********
No errors.
======================================================================
Script: boilerplate.py

Contents:

**********
#!/usr/bin/env python3
"""
boilerplate.py — a template for all Python scripts in The MulQuaBio course.

Demonstrates good coding practice:
- Shebang for portability.
- Module-level docstring (describes purpose, author, version, usage).
- Imports at top.
- main() function encapsulation.
- sys.argv for command-line argument reading.
- __name__ guard.
"""

__author__ = "Your Name <you@example.com>"
__version__ = "0.1.0"
__license__ = "MIT"
__status__ = "Development"

# ---- imports ----
import sys
from pathlib import Path

# ---- functions ----
def greet(name: str = "world") -> str:
    """Return a simple greeting message."""
    return f"Hello, {name}!"

# ---- main ----
def main(argv=None):
    """
    Entry point for command-line execution.

    Parameters
    ----------
    argv : list, optional
        Command-line arguments (defaults to sys.argv[1:]).

    Returns
    -------
    int
        Exit status code (0 for success).
    """
    if argv is None:
        argv = sys.argv[1:]

    # handle arguments
    if len(argv) == 0:
        name = "world"
    else:
        name = argv[0]

    message = greet(name)
    print(message)

    # create an example output file (shows file I/O)
    outdir = Path(__file__).resolve().parents[1] / "results"
    outdir.mkdir(parents=True, exist_ok=True)
    outfile = outdir / "boilerplate_output.txt"
    with open(outfile, "w") as f:
        f.write(message + "\n")

    print(f"[OK] Message written to {outfile}")
    return 0

# ---- script execution ----
if __name__ == "__main__":
    sys.exit(main())

**********

Output (first 500 chars):

**********
Hello, world!
[OK] Message written to /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results/boilerplate_output.txt

**********
No errors.
======================================================================
Script: data.py

Contents:

**********
import re
pat_simple = re.compile(r'^(?:19(0[1-9]|[1-9]\d)|[2-9]\d{3})(?:0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])$')
pat_strict = re.compile(r'''^(?:(?:19(0[1-9]|[1-9]\d)|[2-9]\d{3})(?:(?:0[13578]|1[02])(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)(?:0[1-9]|[12]\d|30)|02(?:0[1-9]|1\d|2[0-8])))|(?:(?:(?:19|[2-9]\d)(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]00|[3579]200))0229)$''')
tests = ["19000101","19010228","20000229","21000229","20250230","20251231"]
for s in tests:
    print(s, bool(pat_simple.match(s)), bool(pat_strict.match(s)))

**********

Output (first 500 chars):

**********
19000101 False False
19010228 True True
20000229 True True
21000229 True False
20250230 True False
20251231 True True

**********
No errors.
======================================================================
Script: lc1.py

Contents:

**********
#!/usr/bin/env python3
"""
lc1.py — Loop -> List comprehension basics with quick self-tests.
"""
from typing import Iterable, List

def squares_loop(n: int) -> List[int]:
    out = []
    for i in range(n):
        out.append(i*i)
    return out

def squares_comp(n: int) -> List[int]:
    return [i*i for i in range(n)]

def evens_comp(seq: Iterable[int]) -> List[int]:
    return [x for x in seq if x % 2 == 0]

def lens_comp(names: Iterable[str]) -> List[int]:
    return [len(s) for s in names]

def flatten_pairs_comp(pairs: Iterable[tuple]) -> List:
    return [item for p in pairs for item in p]

def unique_sorted_comp(seq: Iterable[int]) -> List[int]:
    # “列表推导 + 去重 + 排序”
    return sorted({x for x in seq})

if __name__ == "__main__":
    print("[lc1] squares_loop(6)      =", squares_loop(6))
    print("[lc1] squares_comp(6)      =", squares_comp(6))
    print("[lc1] evens_comp(range(10))=", evens_comp(range(10)))
    print("[lc1] lens_comp(['a','abcd','']) =", lens_comp(["a","abcd",""]))
    print("[lc1] flatten_pairs_comp([(1,2),(3,4)]) =", flatten_pairs_comp([(1,2),(3,4)]))
    print("[lc1] unique_sorted_comp([3,1,2,3,2]) =", unique_sorted_comp([3,1,2,3,2]))

**********

Output (first 500 chars):

**********
[lc1] squares_loop(6)      = [0, 1, 4, 9, 16, 25]
[lc1] squares_comp(6)      = [0, 1, 4, 9, 16, 25]
[lc1] evens_comp(range(10))= [0, 2, 4, 6, 8]
[lc1] lens_comp(['a','abcd','']) = [1, 4, 0]
[lc1] flatten_pairs_comp([(1,2),(3,4)]) = [1, 2, 3, 4]
[lc1] unique_sorted_comp([3,1,2,3,2]) = [1, 2, 3]

**********
No errors.
======================================================================
Script: tuple.py

Contents:

**********
#!/usr/bin/env python3
"""
tuple.py — Tuple basics: packing/unpacking; tuples as dict keys.
"""
from typing import Dict, List, Tuple

def swap(a, b):
    # tuple packing/unpacking
    a, b = b, a
    return a, b

def coords_to_dict(coords: List[Tuple[int,int]], label: str="P") -> Dict[Tuple[int,int], str]:
    # 使用 tuple 作为 key
    return {xy: f"{label}{i}" for i, xy in enumerate(coords, 1)}

def unzip_pairs(pairs: List[Tuple]) -> Tuple[List, List]:
    # 解包 zip(*pairs)
    left, right = zip(*pairs) if pairs else ([], [])
    return list(left), list(right)

if __name__ == "__main__":
    print("[tuple] swap(1,9) =>", swap(1,9))
    print("[tuple] coords_to_dict([(0,0),(1,2)]) =>", coords_to_dict([(0,0),(1,2)]))
    print("[tuple] unzip_pairs =>", unzip_pairs([("a",1),("b",2)]))

**********

Output (first 500 chars):

**********
[tuple] swap(1,9) => (9, 1)
[tuple] coords_to_dict([(0,0),(1,2)]) => {(0, 0): 'P1', (1, 2): 'P2'}
[tuple] unzip_pairs => (['a', 'b'], [1, 2])

**********
No errors.
======================================================================
Script: LV4.py

Contents:

**********
#!/usr/bin/env python3
"""
LV4.py — Discrete-time LV with Gaussian noise on growth rates.
Default: noise on prey growth (r + eps). Optionally also on z (consumer mortality).
"""
import argparse
from pathlib import Path
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def simulate(r=1.0, a=0.5, z=0.3, e=0.75, K=50.0,
             tmax=80, R0=10.0, C0=5.0, sigma=0.05, both=False, seed=1234):
    rng = np.random.default_rng(seed)
    n = int(tmax) + 1
    t = np.arange(n)
    R = np.zeros(n); C = np.zeros(n)
    R[0], C[0] = R0, C0
    for i in range(n-1):
        eps_r = rng.normal(0.0, sigma)
        rr = r + eps_r
        if both:
            eps_z = rng.normal(0.0, sigma)
            zz = max(z + eps_z, 0.0)
        else:
            zz = z
        R[i+1] = max(R[i]*(1 + rr*(1 - R[i]/K) - a*C[i]), 0.0)
        C[i+1] = max(C[i]*(1 - zz + e*a*R[i]), 0.0)
    return t, R, C

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--r", type=float, default=1.0)
    p.add_argument("--a", type=float, default=0.5)
    p.add_argument("--z", type=float, default=0.3)
    p.add_argument("--e", type=float, default=0.75)
    p.add_argument("--K", type=float, default=50.0)
    p.add_argument("--tmax", type=int, default=80)
    p.add_argument("--R0", type=float, default=10.0)
    p.add_argument("--C0", type=float, default=5.0)
    p.add_argument("--sigma", type=float, default=0.05, help="stddev of Gaussian noise")
    p.add_argument("--both", action="store_true", help="also add noise to z")
    p.add_argument("--seed", type=int, default=1234)
    p.add_argument("--pdf", type=str, default=None)
    args = p.parse_args()

    out = Path(args.pdf) if args.pdf else (Path(__file__).resolve().parents[1]/"results"/"LV4.pdf")
    out.parent.mkdir(parents=True, exist_ok=True)

    t, R, C = simulate(args.r,args.a,args.z,args.e,args.K,args.tmax,args.R0,args.C0,args.sigma,args.both,args.seed)
    print(f"Final DT+noise pops -> R: {R[-1]:.6f}, C: {C[-1]:.6f} (t={t[-1]})")

    fig, ax = plt.subplots(figsize=(7,4))
    ax.plot(t, R, label="R (prey)")
    ax.plot(t, C, label="C (predator)")
    ax.set_xlabel("Time step"); ax.set_ylabel("Population")
    ax.set_title("Discrete-time LV with Gaussian noise")
    ax.grid(True); ax.legend(loc="best")
    ax.text(0.02,0.95,
            f"r={args.r}, a={args.a}, z={args.z}, e={args.e}, K={args.K}, sigma={args.sigma}, both={args.both}\nR0={args.R0}, C0={args.C0}",
            transform=ax.transAxes, va="top", ha="left")
    fig.tight_layout(); fig.savefig(out)
    print(f"[OK] Saved plot -> {out}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
Final DT+noise pops -> R: -0.000000, C: 0.000000 (t=80)
[OK] Saved plot -> /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results/LV4.pdf

**********
No errors.
======================================================================
Script: name.py

Contents:

**********
# 姓名由一个或多个“单词”组成，每个单词以字母开头，后续可带字母/数字/撇号/连字符/点，
# 单词之间允许一个或多个空白。
name_re = r"(?:[^\W\d_][\w'’.-]*)(?:\s+(?:[^\W\d_][\w'’.-]*))*"

**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: LV1.py

Contents:

**********
#!/usr/bin/env python3
"""
LV1.py — Basic continuous-time Lotka–Volterra model (predator–prey)
Generates two PDF figures (time series & phase-plane) in ../results/ without showing them.

Model (as in the notes):
    dR/dt = r*R - a*C*R
    dC/dt = -z*C + e*a*C*R
"""

from pathlib import Path
import numpy as np
import scipy.integrate as integrate
import matplotlib
matplotlib.use("Agg")  # ensure no GUI backend is needed
import matplotlib.pyplot as plt

# -----------------------
# Parameters & ICs
# -----------------------
r = 1.0     # intrinsic growth rate of resource (prey)
a = 0.5     # search/attack rate
z = 0.3     # consumer (predator) mortality
e = 0.75    # consumer efficiency
R0 = 10.0   # initial resource density
C0 = 5.0    # initial consumer density
t0, tmax, dt = 0.0, 60.0, 0.01

# Output paths
OUT_DIR = Path(__file__).resolve().parents[1] / "results"
FIG1 = OUT_DIR / "LV_model_timeseries.pdf"
FIG2 = OUT_DIR / "LV_model_phaseplane.pdf"

# -----------------------
# ODE system
# -----------------------
def dCR_dt(pop, t=0.0):
    R, C = pop
    dR = r*R - a*C*R
    dC = -z*C + e*a*C*R
    return np.array([dR, dC])

def main():
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    # time grid & solve
    t = np.arange(t0, tmax + dt, dt)
    pops, infodict = integrate.odeint(dCR_dt, y0=(R0, C0), t=t, full_output=True)

    # ---------------
    # Figure 1: time series
    # ---------------
    fig1, ax1 = plt.subplots(figsize=(7, 4))
    ax1.plot(t, pops[:, 0], "g-", label="Resource R (prey)")
    ax1.plot(t, pops[:, 1], "b-", label="Consumer C (predator)")
    ax1.grid(True)
    ax1.legend(loc="best")
    ax1.set_xlabel("Time")
    ax1.set_ylabel("Population density")
    ax1.set_title("Lotka–Volterra (time series)")
    # Optional: include params in the plot for clarity
    txt = f"r={r}, a={a}, z={z}, e={e}; R0={R0}, C0={C0}"
    ax1.text(0.02, 0.95, txt, transform=ax1.transAxes, va="top", ha="left")
    fig1.tight_layout()
    fig1.savefig(FIG1)
    plt.close(fig1)

    # ---------------
    # Figure 2 (“Fig. 15”): phase-plane (C vs R)
    # ---------------
    R = pops[:, 0]
    C = pops[:, 1]
    fig2, ax2 = plt.subplots(figsize=(5.2, 5.2))
    ax2.plot(R, C, "-")
    ax2.set_xlabel("Resource R")
    ax2.set_ylabel("Consumer C")
    ax2.set_title("Lotka–Volterra (phase plane)")
    ax2.grid(True)
    fig2.tight_layout()
    fig2.savefig(FIG2)
    plt.close(fig2)

    # A small success message (not required by the notes, but handy)
    print(f"[OK] Saved: {FIG1.name}, {FIG2.name} -> {OUT_DIR}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
[OK] Saved: LV_model_timeseries.pdf, LV_model_phaseplane.pdf -> /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results

**********
No errors.
======================================================================
Script: align_seqs.py

Contents:

**********
#!/usr/bin/env python3
"""
Align two DNA sequences by sliding the shorter along the longer and
counting matches; write the best alignment and its score to a text file.
No interactive input is required.
"""
from pathlib import Path
import csv

DATA_IN = Path(__file__).resolve().parents[1] / "data" / "two_seqs.csv"
OUT_DIR = Path(__file__).resolve().parents[1] / "results"
OUT_FILE = OUT_DIR / "best_alignment.txt"

def read_two_sequences(csv_path: Path):
    with open(csv_path, "r", newline="") as f:
        rows = list(csv.reader(f))
    # 允许：两行两列 或 一行两列
    flat = []
    for r in rows:
        flat.extend([c.strip().upper() for c in r if c.strip()])
    if len(flat) < 2:
        raise ValueError("Input CSV must contain two DNA sequences.")
    return flat[0], flat[1]

def score_alignment(longer: str, shorter: str, offset: int) -> int:
    """Count matches when `shorter` is aligned to `longer` starting at `offset`."""
    score = 0
    for i, base in enumerate(shorter):
        j = i + offset
        if j >= len(longer):  # beyond end
            break
        if base == longer[j]:
            score += 1
    return score

def best_alignment(seq1: str, seq2: str):
    # 确保 longer/shorter
    if len(seq1) >= len(seq2):
        longer, shorter = seq1, seq2
        swapped = False
    else:
        longer, shorter = seq2, seq1
        swapped = True

    best = {"score": -1, "offset": 0}
    for offset in range(len(longer)):  # 将短序列起点滑过长序列的每个位置
        s = score_alignment(longer, shorter, offset)
        if s > best["score"]:
            best.update(score=s, offset=offset)

    # 生成可视化对齐字符串
    aligned_shorter = " " * best["offset"] + shorter
    match_line = []
    for i, ch in enumerate(aligned_shorter):
        if i < len(longer) and ch == longer[i]:
            match_line.append("|")
        else:
            match_line.append(" ")
    match_line = "".join(match_line)

    # 若原序列被交换过，在输出里仍按原顺序展示
    if swapped:
        top = seq2
        bottom = " " * best["offset"] + seq1 if len(seq2) < len(seq1) else aligned_shorter
        # 当交换时重新构造对齐行以与输出两行长度一致
        # 简化处理：统一以 longer 在上、对齐 shorter 在下展示
        top = longer
        bottom = aligned_shorter
        mid = match_line
    else:
        top = longer
        bottom = aligned_shorter
        mid = match_line

    return {
        "score": best["score"],
        "offset": best["offset"],
        "longer": longer,
        "shorter": shorter,
        "top": top,
        "mid": mid,
        "bottom": bottom,
    }

def main():
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    s1, s2 = read_two_sequences(DATA_IN)
    res = best_alignment(s1, s2)
    with open(OUT_FILE, "w") as f:
        f.write("# Best alignment result\n")
        f.write(f"Score : {res['score']}\n")
        f.write(f"Offset: {res['offset']}\n\n")
        f.write(res["top"] + "\n")
        f.write(res["mid"] + "\n")
        f.write(res["bottom"] + "\n")
    print(f"[OK] Best alignment written to: {OUT_FILE} (score={res['score']})")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
[OK] Best alignment written to: /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results/best_alignment.txt (score=8)

**********
No errors.
======================================================================
Script: LV3.py

Contents:

**********
#!/usr/bin/env python3
"""
LV3.py — Discrete-time LV with prey density-dependence (K).
Print final populations and save a PDF time-series plot (no GUI).
"""
import argparse
from pathlib import Path
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

def simulate(r=1.0, a=0.5, z=0.3, e=0.75, K=50.0,
             tmax=80, R0=10.0, C0=5.0):
    n = int(tmax) + 1
    t = np.arange(n)
    R = np.zeros(n); C = np.zeros(n)
    R[0], C[0] = R0, C0
    for i in range(n-1):
        R[i+1] = max(R[i]*(1 + r*(1 - R[i]/K) - a*C[i]), 0.0)
        C[i+1] = max(C[i]*(1 - z + e*a*R[i]), 0.0)
    return t, R, C

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--r", type=float, default=1.0)
    p.add_argument("--a", type=float, default=0.5)
    p.add_argument("--z", type=float, default=0.3)
    p.add_argument("--e", type=float, default=0.75)
    p.add_argument("--K", type=float, default=50.0)
    p.add_argument("--tmax", type=int, default=80)
    p.add_argument("--R0", type=float, default=10.0)
    p.add_argument("--C0", type=float, default=5.0)
    p.add_argument("--pdf", type=str, default=None)
    args = p.parse_args()

    out = Path(args.pdf) if args.pdf else (Path(__file__).resolve().parents[1]/"results"/"LV3.pdf")
    out.parent.mkdir(parents=True, exist_ok=True)

    t, R, C = simulate(args.r,args.a,args.z,args.e,args.K,args.tmax,args.R0,args.C0)
    print(f"Final DT pops -> R: {R[-1]:.6f}, C: {C[-1]:.6f} (t={t[-1]})")

    fig, ax = plt.subplots(figsize=(7,4))
    ax.plot(t, R, label="R (prey)")
    ax.plot(t, C, label="C (predator)")
    ax.set_xlabel("Time step"); ax.set_ylabel("Population")
    ax.set_title("Discrete-time LV (with K)")
    ax.grid(True); ax.legend(loc="best")
    ax.text(0.02,0.95,f"r={args.r}, a={args.a}, z={args.z}, e={args.e}, K={args.K}\nR0={args.R0}, C0={args.C0}",
            transform=ax.transAxes, va="top", ha="left")
    fig.tight_layout(); fig.savefig(out)
    print(f"[OK] Saved plot -> {out}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
Final DT pops -> R: -0.000000, C: 0.000000 (t=80)
[OK] Saved plot -> /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results/LV3.pdf

**********
No errors.
======================================================================
Script: LV2.py

Contents:

**********
#!/usr/bin/env python3
"""
LV2.py — Lotka–Volterra with prey density dependence (carrying capacity K).
Takes parameters from CLI, saves a PDF, prints final (non-zero) populations.

Model:
    dR/dt = r*R*(1 - R/K) - a*C*R
    dC/dt = -z*C + e*a*C*R
"""
import argparse
from pathlib import Path
import numpy as np
import matplotlib
matplotlib.use("Agg")  # no GUI
import matplotlib.pyplot as plt

def simulate(r=1.0, a=0.5, z=0.3, e=0.75, K=50.0,
             tmax=60.0, dt=0.01, R0=10.0, C0=5.0):
    n = int(tmax / dt) + 1
    t = np.linspace(0.0, tmax, n)
    R = np.zeros(n); C = np.zeros(n)
    R[0], C[0] = float(R0), float(C0)
    for i in range(n - 1):
        dR = r*R[i]*(1 - R[i]/K) - a*C[i]*R[i]
        dC = -z*C[i] + e*a*C[i]*R[i]
        R[i+1] = max(R[i] + dR*dt, 0.0)
        C[i+1] = max(C[i] + dC*dt, 0.0)
    return t, R, C

def main():
    p = argparse.ArgumentParser(
        description="LV with prey density dependence (K). Saves PDF and prints final populations."
    )
    p.add_argument("--r", type=float, default=1.0)
    p.add_argument("--a", type=float, default=0.5)
    p.add_argument("--z", type=float, default=0.3)
    p.add_argument("--e", type=float, default=0.75)
    p.add_argument("--K", type=float, default=50.0)
    p.add_argument("--tmax", type=float, default=60.0)
    p.add_argument("--dt", type=float, default=0.01)
    p.add_argument("--R0", type=float, default=10.0)
    p.add_argument("--C0", type=float, default=5.0)
    p.add_argument("--pdf", type=str, default=None,
                   help="Output PDF path; default ../results/LV2.pdf")
    args = p.parse_args()

    out_path = Path(args.pdf) if args.pdf else (Path(__file__).resolve().parents[1] / "results" / "LV2.pdf")
    out_path.parent.mkdir(parents=True, exist_ok=True)

    t, R, C = simulate(args.r, args.a, args.z, args.e, args.K, args.tmax, args.dt, args.R0, args.C0)

    # print final (non-zero) populations
    print(f"Final populations -> R: {R[-1]:.6f}, C: {C[-1]:.6f} (t={t[-1]:.2f})")

    # plot
    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(t, R, label="Resource R (prey)")
    ax.plot(t, C, label="Consumer C (predator)")
    ax.set_xlabel("Time")
    ax.set_ylabel("Population")
    ax.set_title("Lotka–Volterra with Prey Density Dependence (K)")
    ax.grid(True)
    ax.legend(loc="best")
    ax.text(
        0.02, 0.95,
        f"r={args.r}, a={args.a}, z={args.z}, e={args.e}, K={args.K}\n"
        f"R0={args.R0}, C0={args.C0}, tmax={args.tmax}, dt={args.dt}",
        transform=ax.transAxes, ha="left", va="top"
    )
    fig.tight_layout()
    fig.savefig(out_path)
    print(f"[OK] Saved plot -> {out_path}")

if __name__ == "__main__":
    main()

**********

Output (first 500 chars):

**********
Final populations -> R: 0.008232, C: 0.332714 (t=60.00)
[OK] Saved plot -> /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week1/results/LV2.pdf

**********
No errors.
======================================================================
Script: utils_plot.R

Contents:

**********
save_pdf_plot <- function(filename, expr, width=6, height=4) {
  pdf(file=filename, width=width, height=height)
  on.exit(dev.off(), add=TRUE)
  force(expr)
  invisible(TRUE)
}

**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: sample.R

Contents:

**********
f_square <- function(x) x^2
f_is_pos <- function(x) x > 0
f_sum_if_pos <- function(v) { s <- sum(v); if (s > 0) return(v*100) else return(v) }

lst <- list(1, -2, 3, -4, 5)
print(lapply(lst, f_square))
print(sapply(lst, f_square))

set.seed(101)

groups <- split(rnorm(1000), rep(1:10, each=100))
means <- sapply(groups, mean)
sds   <- sapply(groups, sd)
print(means); print(sds)

set.seed(2025)
mat_unif <- replicate(10, runif(5))
print(mat_unif)

**********

Output (first 500 chars):

**********
[[1]]
[1] 1

[[2]]
[1] 4

[[3]]
[1] 9

[[4]]
[1] 16

[[5]]
[1] 25

[1]  1  4  9 16 25
           1            2            3            4            5            6 
-0.037191100 -0.042002372  0.002070399 -0.025466513 -0.211317178  0.049601355 
           7            8            9           10 
-0.119904098 -0.136186967  0.052009272  0.119766640 
        1         2         3         4         5         6         7         8 
0.9340710 1.0041724 0.8728203 1.0518271 0.9636738 0.8980010 0.8162695
**********
No errors.
======================================================================
Script: TAutoCorr.R

Contents:

**********

# TAutoCorr.R
# Groupwork Practical: Autocorrelation in Florida weather (successive-year correlation)
# Usage:
#   Rscript TAutoCorr.R --input data/florida_temp.csv --output results/autocorr --nperm 5000
suppressWarnings(suppressMessages({
  args <- commandArgs(trailingOnly = TRUE)
}))

get_arg <- function(flag, default=NULL) {
  idx <- which(args == flag)
  if (length(idx) == 0 || idx == length(args)) return(default)
  args[idx + 1]
}

infile  <- get_arg("--input",  "data/florida_temp.csv")
outstem <- get_arg("--output", "results/autocorr")
nperm   <- as.integer(get_arg("--nperm", "5000"))
dir.create(dirname(outstem), showWarnings=FALSE, recursive=TRUE)

df <- read.csv(infile, header=TRUE)
stopifnot(all(c("Year","Temp") %in% names(df)))
df <- df[order(df$Year), ]

# Compute observed correlation between successive years
# i.e., cor(Temp[t], Temp[t+1]) for t=1..n-1
T_t   <- head(df$Temp, -1)
T_tp1 <- tail(df$Temp, -1)
obs_cor <- cor(T_t, T_tp1, use="complete.obs", method="pearson")

set.seed(123)
perm_cors <- numeric(nperm)
for (i in seq_len(nperm)) {
  shuf <- sample(df$Temp, replace=FALSE)
  perm_cors[i] <- suppressWarnings(cor(shuf[-length(shuf)], shuf[-1], use="complete.obs", method="pearson"))

}

pval <- mean(perm_cors >= obs_cor)

write.csv(data.frame(Year=df$Year, Temp=df$Temp), sprintf("%s_input.csv", outstem), row.names=FALSE)
write.csv(data.frame(observed=obs_cor, p_value=pval), sprintf("%s_stats.csv", outstem), row.names=FALSE)

pdf(sprintf("%s_hist.pdf", outstem), width=6, height=4)
hist(perm_cors, breaks=50, main="Null distribution of successive-year correlation",
     xlab="Correlation under permutation")
abline(v=obs_cor, lwd=2)
legend("topright", legend=sprintf("Observed = %.3f\np = %.4f", obs_cor, pval), bty="n")
dev.off()

# Short LaTeX-ready report (plain text for now)
report <- sprintf(
"Autocorrelation in Florida Weather (Permutation Test)
Observed successive-year correlation (Pearson): %.4f
Permutation p-value (>= observed): %.4f
n_permutations = %d
", obs_cor, pval, nperm)
writeLines(report, con=sprintf("%s_report.txt", outstem))

message("Done. Outputs written to: ", dirname(outstem))

**********

Output (first 500 chars):

**********
null device 
          1 

**********
Errors:
**********
Done. Outputs written to: results

**********
======================================================================
Script: sets_random.R

Contents:

**********


setA <- c(1,2,3,4,5)
setB <- c(4,5,6,7)
print(union(setA, setB))
print(intersect(setA, setB))
print(setdiff(setA, setB))
print(setequal(sort(c(1,2,2,3)), c(1,2,3)))

set.seed(123)
print(rnorm(5, mean=0, sd=1))
set.seed(123)
print(runif(5, min=0, max=2))
set.seed(123)
print(rpois(5, lambda=10))

set.seed(42)
m <- replicate(10, runif(5))
print(m)

**********

Output (first 500 chars):

**********
[1] 1 2 3 4 5 6 7
[1] 4 5
[1] 1 2 3
[1] TRUE
[1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774
[1] 0.5751550 1.5766103 0.8179538 1.7660348 1.8809346
[1]  8  9 14 10 10
          [,1]      [,2]      [,3]      [,4]       [,5]      [,6]        [,7]
[1,] 0.9148060 0.5190959 0.4577418 0.9400145 0.90403139 0.5142118 0.737595618
[2,] 0.9370754 0.7365883 0.7191123 0.9782264 0.13871017 0.3902035 0.811055141
[3,] 0.2861395 0.1346666 0.9346722 0.1174874 0.98889173 0.9057381 0.388108283
[4,] 0
**********
No errors.
======================================================================
Script: functions_practical.R

Contents:

**********


SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return(Tot)
}


NoPreallocFun <- function(x) {
  a <- vector()  
  for (i in 1:x) {
    a <- c(a, i) 
  }
  a
}
PreallocFun <- function(x) {
  a <- numeric(x) 
  for (i in 1:x) a[i] <- i
  a
}


set.seed(1)
M <- matrix(runif(10000), 100, 100)
print("Loop sum time:"); print(system.time(SumAllElements(M)))
print("Vectorized sum time:"); print(system.time(sum(M)))

print(system.time(NoPreallocFun(1000)))
print(system.time(PreallocFun(1000)))

**********

Output (first 500 chars):

**********
[1] "Loop sum time:"
   user  system elapsed 
  0.011   0.000   0.011 
[1] "Vectorized sum time:"
   user  system elapsed 
      0       0       0 
   user  system elapsed 
  0.003   0.000   0.003 
   user  system elapsed 
  0.002   0.000   0.002 

**********
No errors.
======================================================================
Script: control_flow.R

Contents:

**********

# control_flow.R
# Control flow tools: if, else, for, while
a <- TRUE
if (a == TRUE) {
  print("a is TRUE")
} else {
  print("a is FALSE")
}


tot <- 0
for (i in 1:10) { tot <- tot + i }
print(tot)


x <- 1
while (x < 5) { x <- x + 1 }
print(x)


b <- 3
if (b > 2) print("b is greater than 2")

**********

Output (first 500 chars):

**********
[1] "a is TRUE"
[1] 55
[1] 5
[1] "b is greater than 2"

**********
No errors.
======================================================================
Script: basic_warmup.R

Contents:

**********

# basic_warmup.R
# Warmup tasks: variables, vectors, simple stats, matrices, lists, data frames.

# Variables and simple math
a <- 4
print(a)
print(a * a)
a_squared <- a * a
print(sqrt(a_squared))

# Vectors
v <- c(0,1,2,3,4)
print(v)
print(is.vector(v))
print(mean(v)); print(var(v)); print(median(v)); print(sum(v)); print(prod(v + 1)); print(length(v))

# Variable naming
wing.width.cm  <- 1.2
wing.length.cm <- c(4.7, 5.2, 4.8)

# Data structures quick tour
# Vectors
v1 <- c(0.02, 0.5, 1)
v2 <- c("a", "bc", "def", "ghij")
v3 <- c(TRUE, TRUE, FALSE)
print(v1); print(v2); print(v3)

# Type coercion
print(c(0.02, TRUE, 1))     
print(c(0.02, "Mary", 1))   
vchar <- character(3); vnum <- numeric(3)
print(vchar); print(vnum)

# Matrices / arrays
mat1 <- matrix(1:25, 5, 5)
print(mat1)
print(dim(mat1))
mat1_byrow <- matrix(1:25, 5, 5, byrow=TRUE)
print(mat1_byrow)
arr1 <- array(1:50, c(5,5,2))
print(arr1[,,1]); print(arr1[,,2])

# Lists
MyList <- list(1L, "p", FALSE, .001)
print(MyList)
MyList2 <- list(species=c("Quercus robur","Fraxinus excelsior"), age=c(123,84))
print(MyList2$species)
pop1<-list(species='Cancer magister', latitude=48.3, longitude=-123.1,
           startyr=1980,endyr=1985, pop=c(303,402,101,607,802,35))
pop2<-list(lat=56,long=-120, pop=c(1,4,7,7,2,1,2))
pop3<-list(lat=32,long=-10,  pop=c(12,11,2,1,14))
pops<-list(sp1=pop1, sp2=pop2, sp3=pop3)
print(pops$sp1["pop"])
print(pops[[2]]$lat)
pops[[3]]$pop[3] <- 102
print(pops[[3]]$pop)

# Data frame
Col1 <- 1:10
Col2 <- LETTERS[1:10]
set.seed(1)
Col3 <- runif(10)
MyDF <- data.frame(Col1, Col2, Col3)
print(MyDF)

**********

Output (first 500 chars):

**********
[1] 4
[1] 16
[1] 4
[1] 0 1 2 3 4
[1] TRUE
[1] 2
[1] 2.5
[1] 2
[1] 10
[1] 120
[1] 5
[1] 0.02 0.50 1.00
[1] "a"    "bc"   "def"  "ghij"
[1]  TRUE  TRUE FALSE
[1] 0.02 1.00 1.00
[1] "0.02" "Mary" "1"   
[1] "" "" ""
[1] 0 0 0
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    6   11   16   21
[2,]    2    7   12   17   22
[3,]    3    8   13   18   23
[4,]    4    9   14   19   24
[5,]    5   10   15   20   25
[1] 5 5
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
**********
No errors.
======================================================================
Script: vectorization_challenge_ricker.R

Contents:

**********

# vectorization_challenge_ricker.R
# Ricker model vectorization challenge

# Ricker model:
# N_{t+1} = N_t * exp(r * (1 - N_t/K) + e_t)
# where e_t ~ Normal(0, sigma^2)

simulate_ricker_loop <- function(N0=1, r=1.2, K=50, sigma=0.2, n=100) {
  N <- numeric(n+1)
  N[1] <- N0
  eps <- rnorm(n, mean=0, sd=sigma)
  for (t in 1:n) {
    N[t+1] <- N[t] * exp(r * (1 - N[t]/K) + eps[t])
  }
  N
}

simulate_ricker_vectorized <- function(N0=1, r=1.2, K=50, sigma=0.2, n=100) {

  N <- numeric(n+1)
  N[1] <- N0
  eps <- rnorm(n, mean=0, sd=sigma)

  for (t in 1:n) {
    N[t+1] <- N[t] * exp(r * (1 - N[t]/K) + eps[t])
  }
  N
}


set.seed(42)
N1 <- simulate_ricker_loop()
set.seed(42)
N2 <- simulate_ricker_vectorized()

stopifnot(all.equal(N1, N2))

# Timing (moderate n for demo)
library(microbenchmark)
set.seed(123)
tb <- microbenchmark(
  loop = simulate_ricker_loop(n=5000),
  semi_vector = simulate_ricker_vectorized(n=5000),
  times = 10
)
print(tb)
print(summary(tb))

pdf(file="results/ricker_trajectory.pdf", width=6, height=4)
plot(N1, type="l", xlab="Time", ylab="Population size", main="Ricker model trajectory (seed=42)")
lines(N2, col="red", lty=2)
legend("topright", legend=c("loop", "semi-vectorized"), col=c("black","red"), lty=c(1,2), bty="n")
dev.off()

**********

Output (first 500 chars):

**********

**********
Errors:
**********
Error in library(microbenchmark) : 
  there is no package called ‘microbenchmark’
Execution halted

**********
======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/bash
# Author: Your Name
# Script: csvtospace.sh
# Desc: Convert CSV to space-delimited text (without modifying original)
# Usage: bash csvtospace.sh input.csv
# Date: Oct 2025

if [ $# -ne 1 ]; then
  echo "Usage: bash csvtospace.sh input.csv"
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "Error: file '$1' not found!"
  exit 1
fi

input="$1"
base="${input%.*}"
outfile="${base}_space.txt"

tr ',' ' ' < "$input" > "$outfile"
echo "Converted '$input' → '$outfile'"

**********

Output (first 500 chars):

**********
Usage: bash csvtospace.sh input.csv

**********
No errors.
======================================================================
Script: CompileLaTeX.sh

Contents:

**********
#!/bin/bash
pdflatex $1.tex
bibtex $1
pdflatex $1.tex
pdflatex $1.tex

# 仅在有图形界面且存在 evince 时才尝试打开 PDF
if [ -n "${DISPLAY:-}" ] && command -v evince >/dev/null 2>&1; then
    evince $1.pdf &
fi

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg

**********

Output (first 500 chars):

**********
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(/usr/share/texlive/texmf-dist/tex/latex/tools/.tex
LaTeX2e <2023-11-01> patch level 1
L3 programming layer <2024-01-22>
File ignored)
*
! Emergency stop.
<*> 
    
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on .log.
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex
**********
Errors:
**********
bibtex: Need exactly one file argument.
Try `bibtex --help' for more information.
rm: cannot remove '*.aux': No such file or directory
rm: cannot remove '*.log': No such file or directory
rm: cannot remove '*.bbl': No such file or directory
rm: cannot remove '*.blg': No such file or directory

**********
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash
# Script: tiff2png.sh
# Desc: Convert all .tif images in current directory to .png

for f in *.tif; do
  [ -f "$f" ] || continue
  echo "Converting $f ..."
  convert "$f" "$(basename "$f" .tif).png"
done
echo "All conversions done."

**********

Output (first 500 chars):

**********
All conversions done.

**********
No errors.
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: Your Name your.login@imperial.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2025

echo -e "\nThis is a shell script! \n"

**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: ConcatenateTwoFiles.sh

Contents:

**********
#!/bin/bash
# Script: ConcatenateTwoFiles.sh
# Desc: Merge two files into a third file
# Usage: bash ConcatenateTwoFiles.sh file1 file2 mergedfile

if [ $# -ne 3 ]; then
  echo "Usage: bash ConcatenateTwoFiles.sh file1 file2 output"
  exit 1
fi

cat "$1" > "$3"
cat "$2" >> "$3"
echo "Merged file created: $3"


**********

Output (first 500 chars):

**********
Usage: bash ConcatenateTwoFiles.sh file1 file2 output

**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: Your Name
# Script: tabtocsv.sh
# Desc: convert tab-delimited file to CSV
# Usage: bash tabtocsv.sh inputfile
# Date: Oct 2025

if [ $# -ne 1 ]; then
  echo "Error: please provide exactly one input file."
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "Error: file '$1' not found!"
  exit 1
fi

echo "Creating a comma delimited version of $1 ..."
outfile="${1}.csv"
tr -s '\t' ',' < "$1" > "$outfile"
echo "Done! Saved as $outfile"

**********

Output (first 500 chars):

**********
Error: please provide exactly one input file.

**********
No errors.
======================================================================
Script: MyExampleScript.sh

Contents:

**********
#!/bin/sh
# A short script showing use of environment variables
MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"

**********

Output (first 500 chars):

**********
Hello mhasoba

**********
No errors.
======================================================================
Script: run_all.sh

Contents:

**********
#!/bin/bash
# Author: Your Name
# Script: run_all.sh
# Desc: Location-agnostic runner for all scripts. It auto-creates ../sandbox & ../data
# Date: Oct 2025
set -euo pipefail

echo "========== Running all scripts (location-agnostic) =========="

# 计算当前脚本所在目录（而不是调用时所在目录）
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SANDBOX="${DIR}/../sandbox"
DATA="${DIR}/../data"

# 保证目录存在
mkdir -p "$SANDBOX" "$DATA"

# 1. boilerplate.sh
echo -e "\n--- Running boilerplate.sh ---"
bash "$DIR/boilerplate.sh"

# 2. variables.sh （用管道喂输入，避免交互）
echo -e "\n--- Running variables.sh ---"
printf "new_string\n3 5\n" | bash "$DIR/variables.sh" arg1 arg2

# 3. MyExampleScript.sh
echo -e "\n--- Running MyExampleScript.sh ---"
bash "$DIR/MyExampleScript.sh"

# 4. 准备测试文件（放在 ../sandbox 里）
echo -e "col1\tcol2\tcol3\n1\t2\t3\n4\t5\t6" > "${SANDBOX}/test_tab.txt"
echo -e "col1,col2,col3\n7,8,9\n10,11,12" > "${SANDBOX}/test_csv.csv"
echo "file1 line" > "${SANDBOX}/file1.txt"
echo "file2 line" > "${SANDBOX}/file2.txt"

# 5. tabtocsv.sh
echo -e "\n--- Running tabtocsv.sh ---"
bash "$DIR/tabtocsv.sh" "${SANDBOX}/test_tab.txt"

# 6. csvtospace.sh
echo -e "\n--- Running csvtospace.sh ---"
bash "$DIR/csvtospace.sh" "${SANDBOX}/test_csv.csv"

# 7. CountLines.sh
echo -e "\n--- Running CountLines.sh ---"
bash "$DIR/CountLines.sh" "${SANDBOX}/test_tab.txt"

# 8. ConcatenateTwoFiles.sh
echo -e "\n--- Running ConcatenateTwoFiles.sh ---"
bash "$DIR/ConcatenateTwoFiles.sh" "${SANDBOX}/file1.txt" "${SANDBOX}/file2.txt" "${SANDBOX}/merged.txt"

# 9. tiff2png.sh （若无 convert 或无 .tif，则跳过）
echo -e "\n--- Running tiff2png.sh (conditional) ---"
if command -v convert >/dev/null 2>&1; then
  # 在 sandbox 放一个空的示例 tif（可选）
  # : > "${SANDBOX}/example.tif"
  (cd "$SANDBOX" && bash "$DIR/tiff2png.sh")
else
  echo "Skip: 'convert' not found (ImageMagick not installed)."
fi

echo -e "\n========== All scripts executed =========="

**********

Output (first 500 chars):

**********
========== Running all scripts (location-agnostic) ==========

--- Running boilerplate.sh ---

This is a shell script! 


--- Running variables.sh ---
This script was called with 2 parameters
The script's name is /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week2/Code/variables.sh
The arguments are arg1 arg2
The first argument is arg1
The second argument is arg2
The current value of MY_VAR is: some string

Please enter a new string:
Now MY_VAR is: n
**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh
# Script illustrating variable use

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

MY_VAR='some string'
echo 'The current value of MY_VAR is:' $MY_VAR
echo
echo 'Please enter a new string:'
read MY_VAR
echo 'Now MY_VAR is:' $MY_VAR
echo

echo 'Enter two numbers separated by space(s):'
read a b
MY_SUM=$(expr $a + $b)
echo "You entered $a and $b. Their sum is: $MY_SUM"

**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
The current value of MY_VAR is: some string

Please enter a new string:
Now MY_VAR is:

Enter two numbers separated by space(s):
You entered  and . Their sum is: 

**********
Errors:
**********
expr: syntax error: missing argument after ‘+’

**********
======================================================================
Script: CountLines.sh

Contents:

**********
#!/bin/bash
# Script: CountLines.sh
# Desc: Count the number of lines in a file
# Usage: bash CountLines.sh file.txt

if [ $# -ne 1 ]; then
  echo "Usage: bash CountLines.sh filename"
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "File not found!"
  exit 1
fi

NumLines=$(wc -l < "$1")
echo "The file $1 has $NumLines lines"

**********

Output (first 500 chars):

**********
Usage: bash CountLines.sh filename

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 35
Scripts successful: 30
Scripts with errors: 5
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

