======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Hanxiao Wang

Processing week 2

Your current Git repo size is about 147.79 KiB on disk

Found directories: .git, week1, week2, Feedback
Found files: .gitignore, README.md

Processing week 2: week2

Found 10 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/bash
# Author: Your Name
# Script: csvtospace.sh
# Desc: Convert CSV to space-delimited text (without modifying original)
# Usage: bash csvtospace.sh input.csv
# Date: Oct 2025

if [ $# -ne 1 ]; then
  echo "Usage: bash csvtospace.sh input.csv"
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "Error: file '$1' not found!"
  exit 1
fi

input="$1"
base="${input%.*}"
outfile="${base}_space.txt"

tr ',' ' ' < "$input" > "$outfile"
echo "Converted '$input' → '$outfile'"

**********

Output (first 500 chars):

**********
Usage: bash csvtospace.sh input.csv

**********
No errors.
======================================================================
Script: CompileLaTeX.sh

Contents:

**********
#!/bin/bash
pdflatex $1.tex
bibtex $1
pdflatex $1.tex
pdflatex $1.tex

# 仅在有图形界面且存在 evince 时才尝试打开 PDF
if [ -n "${DISPLAY:-}" ] && command -v evince >/dev/null 2>&1; then
    evince $1.pdf &
fi

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg

**********

Output (first 500 chars):

**********
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(/usr/share/texlive/texmf-dist/tex/latex/tools/.tex
LaTeX2e <2023-11-01> patch level 1
L3 programming layer <2024-01-22>
File ignored)
*
! Emergency stop.
<*> 
    
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on .log.
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex
**********
Errors:
**********
bibtex: Need exactly one file argument.
Try `bibtex --help' for more information.
rm: cannot remove '*.aux': No such file or directory
rm: cannot remove '*.log': No such file or directory
rm: cannot remove '*.bbl': No such file or directory
rm: cannot remove '*.blg': No such file or directory

**********
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash
# Script: tiff2png.sh
# Desc: Convert all .tif images in current directory to .png

for f in *.tif; do
  [ -f "$f" ] || continue
  echo "Converting $f ..."
  convert "$f" "$(basename "$f" .tif).png"
done
echo "All conversions done."

**********

Output (first 500 chars):

**********
All conversions done.

**********
No errors.
======================================================================
Script: boilerplate.sh

Contents:

**********
#!/bin/sh
# Author: Your Name your.login@imperial.ac.uk
# Script: boilerplate.sh
# Desc: simple boilerplate for shell scripts
# Arguments: none
# Date: Oct 2025

echo -e "\nThis is a shell script! \n"

**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: ConcatenateTwoFiles.sh

Contents:

**********
#!/bin/bash
# Script: ConcatenateTwoFiles.sh
# Desc: Merge two files into a third file
# Usage: bash ConcatenateTwoFiles.sh file1 file2 mergedfile

if [ $# -ne 3 ]; then
  echo "Usage: bash ConcatenateTwoFiles.sh file1 file2 output"
  exit 1
fi

cat "$1" > "$3"
cat "$2" >> "$3"
echo "Merged file created: $3"


**********

Output (first 500 chars):

**********
Usage: bash ConcatenateTwoFiles.sh file1 file2 output

**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: Your Name
# Script: tabtocsv.sh
# Desc: convert tab-delimited file to CSV
# Usage: bash tabtocsv.sh inputfile
# Date: Oct 2025

if [ $# -ne 1 ]; then
  echo "Error: please provide exactly one input file."
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "Error: file '$1' not found!"
  exit 1
fi

echo "Creating a comma delimited version of $1 ..."
outfile="${1}.csv"
tr -s '\t' ',' < "$1" > "$outfile"
echo "Done! Saved as $outfile"

**********

Output (first 500 chars):

**********
Error: please provide exactly one input file.

**********
No errors.
======================================================================
Script: MyExampleScript.sh

Contents:

**********
#!/bin/sh
# A short script showing use of environment variables
MSG1="Hello"
MSG2=$USER
echo "$MSG1 $MSG2"

**********

Output (first 500 chars):

**********
Hello mhasoba

**********
No errors.
======================================================================
Script: run_all.sh

Contents:

**********
#!/bin/bash
# Author: Your Name
# Script: run_all.sh
# Desc: Location-agnostic runner for all scripts. It auto-creates ../sandbox & ../data
# Date: Oct 2025
set -euo pipefail

echo "========== Running all scripts (location-agnostic) =========="

# 计算当前脚本所在目录（而不是调用时所在目录）
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SANDBOX="${DIR}/../sandbox"
DATA="${DIR}/../data"

# 保证目录存在
mkdir -p "$SANDBOX" "$DATA"

# 1. boilerplate.sh
echo -e "\n--- Running boilerplate.sh ---"
bash "$DIR/boilerplate.sh"

# 2. variables.sh （用管道喂输入，避免交互）
echo -e "\n--- Running variables.sh ---"
printf "new_string\n3 5\n" | bash "$DIR/variables.sh" arg1 arg2

# 3. MyExampleScript.sh
echo -e "\n--- Running MyExampleScript.sh ---"
bash "$DIR/MyExampleScript.sh"

# 4. 准备测试文件（放在 ../sandbox 里）
echo -e "col1\tcol2\tcol3\n1\t2\t3\n4\t5\t6" > "${SANDBOX}/test_tab.txt"
echo -e "col1,col2,col3\n7,8,9\n10,11,12" > "${SANDBOX}/test_csv.csv"
echo "file1 line" > "${SANDBOX}/file1.txt"
echo "file2 line" > "${SANDBOX}/file2.txt"

# 5. tabtocsv.sh
echo -e "\n--- Running tabtocsv.sh ---"
bash "$DIR/tabtocsv.sh" "${SANDBOX}/test_tab.txt"

# 6. csvtospace.sh
echo -e "\n--- Running csvtospace.sh ---"
bash "$DIR/csvtospace.sh" "${SANDBOX}/test_csv.csv"

# 7. CountLines.sh
echo -e "\n--- Running CountLines.sh ---"
bash "$DIR/CountLines.sh" "${SANDBOX}/test_tab.txt"

# 8. ConcatenateTwoFiles.sh
echo -e "\n--- Running ConcatenateTwoFiles.sh ---"
bash "$DIR/ConcatenateTwoFiles.sh" "${SANDBOX}/file1.txt" "${SANDBOX}/file2.txt" "${SANDBOX}/merged.txt"

# 9. tiff2png.sh （若无 convert 或无 .tif，则跳过）
echo -e "\n--- Running tiff2png.sh (conditional) ---"
if command -v convert >/dev/null 2>&1; then
  # 在 sandbox 放一个空的示例 tif（可选）
  # : > "${SANDBOX}/example.tif"
  (cd "$SANDBOX" && bash "$DIR/tiff2png.sh")
else
  echo "Skip: 'convert' not found (ImageMagick not installed)."
fi

echo -e "\n========== All scripts executed =========="

**********

Output (first 500 chars):

**********
========== Running all scripts (location-agnostic) ==========

--- Running boilerplate.sh ---

This is a shell script! 


--- Running variables.sh ---
This script was called with 2 parameters
The script's name is /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/HanxiaoWang_hw2625/week2/Code/variables.sh
The arguments are arg1 arg2
The first argument is arg1
The second argument is arg2
The current value of MY_VAR is: some string

Please enter a new string:
Now MY_VAR is: n
**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh
# Script illustrating variable use

echo "This script was called with $# parameters"
echo "The script's name is $0"
echo "The arguments are $@"
echo "The first argument is $1"
echo "The second argument is $2"

MY_VAR='some string'
echo 'The current value of MY_VAR is:' $MY_VAR
echo
echo 'Please enter a new string:'
read MY_VAR
echo 'Now MY_VAR is:' $MY_VAR
echo

echo 'Enter two numbers separated by space(s):'
read a b
MY_SUM=$(expr $a + $b)
echo "You entered $a and $b. Their sum is: $MY_SUM"

**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh
The arguments are 
The first argument is 
The second argument is 
The current value of MY_VAR is: some string

Please enter a new string:
Now MY_VAR is:

Enter two numbers separated by space(s):
You entered  and . Their sum is: 

**********
Errors:
**********
expr: syntax error: missing argument after ‘+’

**********
======================================================================
Script: CountLines.sh

Contents:

**********
#!/bin/bash
# Script: CountLines.sh
# Desc: Count the number of lines in a file
# Usage: bash CountLines.sh file.txt

if [ $# -ne 1 ]; then
  echo "Usage: bash CountLines.sh filename"
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "File not found!"
  exit 1
fi

NumLines=$(wc -l < "$1")
echo "The file $1 has $NumLines lines"

**********

Output (first 500 chars):

**********
Usage: bash CountLines.sh filename

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 10
Scripts successful: 8
Scripts with errors: 2
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

